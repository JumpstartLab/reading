# Chapter 10 - Programming Languages Explained

## Summary
  
* Programming languages funnel instructions to machines. Having a variety of languages that vary in "abstractness" lets us get instructions to hardware while still working in vaguely human-readable forms.

* Abstractness varies from machine language, which represents in a literal form everything the computer can do, to more abstract forms, which are used to translate human-readable instructions down to machine language. At the outer end of this "abstraction scale" are languages like Ruby, Python, Haskell, etc, which place most emphasis on human readability and comprehension.

* Cheapness and availability of microprocessors has led to a rapid increase in programming languages being written. The success of open source languages like Perl, Ruby, etc. and the "nerd-cred" they bring to their designers motivates others to try their hand at producing languages as well.

* Despite corporate notions of proprietary secrecy etc, open source often actually translates to more reliable performance and fewer security issues (many eyes are better than few). 

* Experienced programmers commonly develop the habit of thinking in their language of choice. While this may make them faster coders it can also make them more resistant to taking on new ideas about other languages.

* There are nearly as many axes along which programming languages can be compared as there are languages themselves. These include issues like Object Orientation vs. Imperative vs. Functional Programming, Dynamic vs. Static Typing, Weak vs. Strong typing, Interpreted vs. Compiled, etc. While certain languages will inevitably be better at certain tasks, in general, the more robust languages will be those that give flexibility for a variety of approaches (like Ruby!)


## What Stood Out

* Open Source and intellectual property go hand in hand. 

* What ships to the user is essentially the machine language.

* Languages are not all the same - but many of those who insist one is better than the other say so because they are just used to their 'home' language.

> "for the little, everyday problems that programmers spend so much of their time solving, libraries are probably more important than the core language. and so these odd hybrids are quite useful, and become correspondingly popular" - _Paul Graham_

* While the author didn't touch on this directly, he seemed to imply that an operating system written in a high-level language is feasible. It would be an interesting thought experiment to figure out where Ruby would have trouble being an operating system; it might never be fast but it would certainly be extensible.

* Choosing a language should be about what you are trying to achieve however most programmers don't like to leave their language of choice.

* I never knew there was source code and object code. After learning what object code is, it makes sense as to why Windows has made a ton of money.

* I didn't know that Java prevented the programmer from doing "dumb stuff", nor did I know most operating systems were written in C. Though that makes sense as to why Java and C are so widely taught.

* Just like Jeff said on day one - computer time is cheap and programmer time is expensive (while it used to be the opposite). Thus we get to use nice things like Ruby instead of gross things like Assembly.



## Questions Unanswered

* Does anyone still write in assembly language and for what purpose? 

* PG suggests that open source software is the best type of software. What are the advantages of being a big company? If Microsoft were to open source Windows, how would it make its money?

* If the current explosion of languages is a good or a bad thing - is it creating too many compartmentalized programmers and apps?

* How does one choose which language to use, or which qualities are best to use in a language?

* I liked that he said that it was nonsense that all languages are equal. It seems clear that some are better than others, yet there will always be people arguing the contrary.

* What leads programmers to learn one language vs. another?

* Which languages are the most accessible from a learning perspective?  

* Which ones are most pervasive in the industry/each industry?  

* How does one actually go about writing a new language, and why would one do that, given the languages and libraries available to programmers today?

* In terms of open source and more closed systems, what is the true benefit of open source given the success of the iPhone for example?

* What's the benefit of creating another language? I get that some just don't do what is needed, but is it better to have 500 languages than say 100?

* It would have been cool to get a more extensive summary of the broad philosophies behind a handful of popular languages - an ethnography of sorts of the current language landscape.


## Objections

* conventions of language are the same in programming and people languages. 

* OO work is not a binary and is a more complicated debate based on notions of degrees of object-orientedness 

* Paul Graham believes that OSS is the holy grail of software development. OSS has its downfalls, mainly in that people are not getting paid to do something, which means that they are not doing it full-time. He even said that for something to be excellent you need no less than 100% commitment. OSS has both it's good and bad.

* “Some languages are object-oriented in the sense that they let you program in that style, and others in the sense that they force you to. I see little advantage in the latter. Surely a language that lets you do x is at least as good as one that forces you to.” Is this statement really true? Could be advantageous to have code that looks similar across different programmers by the sheer nature that you cannot write it any other way.


## Takeaways

* A language that lets you do X is at least as good as one that forces you to

* Languages are tools and it's good to understand many of them. Choose the right tool for the job.

> "so it is probably good that programmers live in a post-Babel world.  if we were all using the same language it would probably be the wrong one" - _Paul Graham_

* In specific cases, a language's libraries may matter more than its core functionality.

* If you use a language for long enough, you start to think in it.

* Thank God for my compiler that translates everything I write into useable code.

* Source code is readable. Object code isn't. Well, it's just tougher.
* Dynamic typing allows you to define a variable whenever.
* Static typing is set, preventing bugs and generating code faster.

* Most languages can be used to accomplish roughly the same tasks, but you still want to be sensitive to choosing the right tool for the job.

