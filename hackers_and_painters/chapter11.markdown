# Chapter 11


##Summarize the chapter ( 1+ bullets )

1.  Despite the fact that technology changes rapidly, it is reasonable to assume that we could predict what the programming language that we'll use in 100 years will look like.
2.  Current languages that have to date served as models for other languages to date will likely continue to serve as languages (or guide the evolutions of languages) in the future.
3.  If hardware continues to improve at the same rate that it has in the past, then we can also safely assume that future languages will give preference to user accessibility over hardware efficiency.
4.  That being said, the ideal language of the future would opt for usability and simplicity in most situations, but have the capacity to optimize performance over usability.  
5.  It is likely that there will be fewer languages than now as ideas will converge.


##What was one idea the surprised or stood out to you? Why? ( 2-4 sentences )

1.  > "could a programming language go so far as to get rid of numbers as a fundamental data type?" - _Paul Graham_
  * That the notion of strings, integers, arrays, etc. could be gone (or vastly different) in a hundred years.
2.  Wasting programmer time is inefficient & gross. Wasting machine time is not.
3.  > “The desire for speed is so deeply ingrained in us, with our puny computers, that it will take a conscious effort to overcome it. In language design, we should be consciously seeking out situations where we can trade efficiency for even the smallest increase in convenience.” This is interesting to me because I have never thought in terms of convenience, and instead have learned to think only in terms of speed.  In my computer science classes, we always discussed time complexity and never convenience of language. - _Paul Graham_
4.  Parallelism won't be as pervasive.


##What was a question that you saw as unanswered? ( 1-2 sentences )

1.  If the language of the future can be written today why don't we have it already?
2.  Why is it inherently better to be near the middle of the evolutionary branch? I can think of a number of tools that are very specific to a problem of its era that are quite efficient at what they do and that will never spawn a descendant. I don't say that it's always better to select the specialized tool, but I'm hardly convinced that the converse is true.
3.  PG guesses that even in 100 years we still won't be able to "just tell computers what we want them to do" because there hasn't been much progress thus far. But really? _All_the progress that has ever been made on computers - period - dates to about 60 years ago, and most signs indicate it has been speeding up during that time. So this seems like an unreliable way to diagnose what will be possible 100 years from now.
4.  I would have loved to see a more in-depth analysis of present-day languages, outlining in specifics why they likely won't be considered the 100-year language. Alternaively, highlighting some cutting-edge languages that are pushing the envelope would have been an interesting topic to read.


##Did you have any objections or disagreements? ( 1-2 sentences)

1. Purposefully designing a language for implementation or use in one-hundred years seems to be at odds with the espousal of the "emergent" ethos of software development and beauty that graham has previously professed
2.  I thought his view that we would not use hardware improvements like parallel processing may not have been giving programmers enough credit. So far, it seems as if every innovation squeezes everything it can out of the hardware available.
3.  While getting farther away from the computer is desirable in terms of getting more people to learn to program, it has the potential to have fewer people understanding truly what is happening through all of the levels of interpretation, as long as it works. that could potentially stunt innovation.
4.  While the notion of "stay on a main branch" obviously makes some sense for language design, it sort of seems counter to the antiestablishment spirit of innovation championed in earlier chapters. It seems like the branches of languages that die out are still incredibly important for the lessons that they teach the discipline as a whole.


##What were your key take aways or things you want to remember? ( 1+ bullets )**

1.  100 years from now programs will still look like programs to our eyes, even if we don't know the language they're written in and the concepts involved have evolved past our easy understanding. So why not write the 100 year language now?
2.  Each layer of interpretation (or abstraction) in a language costs a factor of ten in speed.
3.  As hardware continues to get faster, there will be good ways to use the extra speed and bad ways - a good way is to take advantage of it to improve the elegance of our language and software designs (another case of people time being more valuable than computer time)
4.  Basically, do everything with an eye to the future. Whether it's language design or something completely different, take into account how it we'll use it 1 year, 10 years, or 100 years from now.