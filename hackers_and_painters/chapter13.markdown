# Chapter 13 - Revenge of the Nerds

## Summary
  
* Not all programming languages are equal. Be wary of people that does not understand technology, yet seems to have very strong opinions on it.
* Lisp was originally developed as a "theoretical exercise" until one of John McCarthy's grad students programmed a Lisp interpreter to actually function as a programming language.
* Lisp was the first language to support many new concepts such as: conditionals, recursion, dynamic typing, and garbage collection.
* Corporations like industry-standard languages; they reduce risk and make it easier to hire programmers, even though a more powerful language would better solve their problem.
* Dynamic programming is an important feature set in programming languages.
* Choosing to develop in a more powerful language may reduce the size of your team because you won't need to hire as many hackers.
* Don't let VCs or potentials acquirers design your product. Design the product to please users and everything else will follow.
* If you want to win in technology, pick the hardest problem and the most powerful language to solve it with.

## What Stood Out

* Lisp is far more influential on modern languages than I had thought (such as lambdas and garbage collection). I had always thought C was the main driver of most modern day languages.
* At the time Paul wrote this, Ruby seemed to possess much of the power that Paul loves about Lisp.
* A lot of the features in Lisp are present in modern languages. I think the biggest one that stands out is garbage collection.
* Let hackers make the technical decisions, not the pointy-haired, middle managers.
* LivingSocial chooses the “industry standard,” RoR.

## Questions Unanswered

* If Lisp is so great, why aren't we hearing about more companies using it today?
* Why haven't more languages adopted Lisp-like features (e.g., macros)?

## Objections

* I believe that the power of a language is limted by the libraries available to it. If a library doesn't exist, you can certainly make one in the language that you are using.
* I'm starting to think that what he means by "powerful" is "elegant" - he explicitly acknowledges that all turing-complete languages are technically as powerful as each other, but that Lisp is more "powerful" because you can do things in fewer discrete syntactic elements.
* Lisp doesnt seem better than ruby if ruby does the same thing in the same amount of lines (assuming other examples are similar), looks cleaner, and is more widely adopted.
* It's a subjective assertion to say that the smartest programmers use the most powerful languages.

## Takeaways

* To win in technology, pick the hardest problem and the most powerful language to solve it with.
* Choosing the correct language for the job can be the difference between you beating your competitors, and your competitors beating you.
