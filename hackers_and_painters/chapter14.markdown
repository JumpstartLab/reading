# Chapter 14 - The Dream Language

## Summary
  
* Graham lists what the characteristics of a dream language are: simple, not
  verbose, libraries, open source, good community, quick to prototype, and lots
  of abstractions that make sense to hackers. It has a built in profiler and
  perhaps tells you when your algorithms are not optimized. If the language
  lets you write inline code to optimize, even better.
* Greater levels of abstraction mean fewer tokens and less typing. Hackers are lazy.
* The Dream Language is not only open source, but open design

## What was one idea that surprised or stood out to you? Why?

* "A programming language does need a good implementation of course, and this must be free. Companies will pay but hackers will not, and this is who you need to attract."
* Of all tyrannies, a tyranny exercised for the good of it's victims may be the most oppressive. - C.S. Lewis
* A language does not necessarily have to be good to be popular, but if has to be popular to be good, and it has to stay popular to stay good.
* Most of the code you write for an application should be specific to that need. If you find yourself rewriting the same code in separate applications you are likely working with something that should be extracted.

## Questions Unanswered

* Does Graham consider Lisp to be this dream language? If so, is Lisp worth learning today?
* Java is popular largely because of it's backing from Sun. How does corporate influence play a role?
* In Hackability Graham suggests a good language will allow a hacker to do whatever they want; surely some constraints are necessary?

## Objections

* Graham thinks that large libraries may become cumbersome and that finding a particular function may not be worth the time; your own implementation might be faster. Github seems to disprove this hypothesis.
* Graham argues that a good language needs to be part of a platform, and that you should not have to download it specifically. I disagree with this notion, as many people, including myself, have no problem configuring their environment to support a new language if they want to try it. Hackers specifically are extraordinarily competent users, and aside from that it is a small matter to release a convenient installation script.
* Is it necessarily the case that a language needs to be around for a couple of years before programmers are willing to adopt it? It seems that hackers today are more willing to occupy the bleeding edge. Node.js is a good example of this, although it's staying power is obviously uncertain.

## Takeaways

* Be optimistic about your ability to solve the problem and pessimistic about your current solution.
* Nearly all the code in any program you write should be code that is specific to your application.
* It takes a long time to get your language off the ground, so be patient and take advantage of the time to make it better by listening to users.
* Enabling quick prototyping is a must for a good language. Hackers want to get started quickly without all of the mental startup cost.