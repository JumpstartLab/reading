# Chapter 1
## Summary
Graham discusses why he believes nerds are unpopular in school. He describes how the smart kids often feel ostracized at school because they: are often a safe target for the other kids to prove their popularity, "nerds" often are so focused on grades and their interests and don't be as personable as they could be, and that suburbia encourages the bizarre enraged teenager that seems to be on the rise in school. 

He also believes schools are basically horrible places that have created a bizarre hierarchical system where the adults can avoid dealing with teenagers.

## Idea that surprised me
That he believes suburbia causes many problems with today's teenagers. And that teenagers would benefit from more real world training when they are young.

## Unanswered question
How we should actually fix schools, whether being smart is really looked down upon in current society (in the age of crazy intense college admissions, gaining fame, etc).  

## Objections
Object to the entire thesis more or less. High schools have some problems, but the idea that schools create these horrible individuals whose sole drive is to torture "nerds" read to me as someone with a huge chip on his shoulder. He offers no evidence for his outlandish beliefs. There's something to be said for increasing the amount of real world work students do in school, but that idea is lost amidst his clear anger at his upbringing.

## Takeaways
That adults and teenagers should have more interaction.

# Chapter 2
## Summary
He doesn't like the term "computer science" and prefers to think of "hackers" as akin to painters, as they are mostly just trying to make interesting software. Computer science is different from "hacking" and he believes "hackers" don't have to understand the theories of computation that are often the focus in computer science programs.
## Idea that surprised me
That relentless attention to detail can result in success in any field.
## Unanswered questions
Why he keeps making the comparison between hacking and architecture when much like computer science, architecture contains many fields that include design, engineering, materials, visuals, efficiency, etc. Just because a person chooses to focus on one part or the other does not mean that they are not part of the entire field.
## Objections/disagreements
While the overall argument is somewhat sound, he's far more concerned with labels and such than he needs to be. I don't find computer science as disparate as he claims to be. He believes hackers can learn to program by just looking at good programs. That may be true for some people, but not everyone. 
## Key takeaways
He seems more focused on the creation of software itself than actually creating software that people enjoy to use.

# Chapter 3
## Summary
He discusses the concept of taboos—how some ideas and beliefs can be thought of as heresy or laughed in certain times and historical eras.
## Idea that surprised me
Always question even the most entrenched ideas. This questioning can often produce the most unique and insightful new ideas.
## Unanswered questions
Eh. Whether life is worth going though just thinking whatever you want without having the courage to say it. 
## Objections/disagreements
I'd love to see some actual documented research in these articles. His ideas of how taboos are created are somewhat interesting but again he doesn't provide evidence to support his theories.
## Key takeaways
That Paul Graham is enormously full of himself. And to always question things, even such things as if the author of the book you are reading is a nutjob.

# Chapter 4
## Summary
Good hackers are often ones who enjoy breaking the rules or subverting authority in order to stimulate their intellectual curiosity. Copyright laws can harm both successful hackers and the content they claim to create.
## Idea that surprised me
Hackers are the first line of defense against infringements on civil liberties.
## Unanswered questions
Whether all hackers are "smart alecs"—he's making sweeping generalizations.
## Objections/disagreements 
This was the first chapter that I actually enjoyed and wasn't riddled with flaws, no disagreements.
## Key takeaways
Balancing the desire for hackers to subvert the rules and have fun with going too far and helping to impose restrictions that the hackers would otherwise oppose (such as Napster).

# Chapter 5
## Summary
Describes the birth of web applications, where you accessed an app run on a server through a web browser. Discusses some of the differences in developing desktop and web applications, such as release windows and dealing with bugs. And discusses some of the benefits of web-based software, such as closer interaction with users, easier customer support, and lower expenses.
## Idea that surprised me
How close he was to predicting the future of web and desktop applications and getting version 1.0 out as fast as possible.
## Unanswered questions
I'd love to see an updated version of this essay in times of social media, ridiculously inexpensive server and hardware, and the rise of the 'app'—how does his thesis hold up today? 
## Objections/disagreements
He doesn't give big businesses such as IBM and Microsoft enough credit for the work they did. Yes, startups are awesome, but sometimes you still need the big boys in order to make real chance across the board.
## Key takeaways
Trying to determine what the 'next' kind of software will be, following the current focus on the app.

# Chapter 6
## Summary
Discusses how to make "wealth" not money, where wealth is the stuff we want and money is just a side effect. He also proposes that the "big pie" (that all the wealth in the world is fixed) is incorrect and that people can create wealth that just makes the pie bigger.
## Idea that surprised me
That he's a huge libertarian. I've always been interested that the majority of Silicon Valley supports Democrats yet often have very conservative ideas about business.
## Unanswered questions
Whether getting bought is a good thing for a startup. He's so against the slowness of big business, yet recommends that start ups be bought by big companies.
## Objections/disagreements
I don't believe startups are the only way of working faster. And, working faster isn't always the best thing. MySpace emerged before Facebook, yet Facebook was a better product. It's much more important to focus on quality rather than just being the first out of the gate. Also, he implies that wealth is the only reason people want to develop new technology, which is quite pessimistic. 
## Key takeaways
Efficiency is more important than speed, and efficiency can occur in both small and big companies.

# Chapter 7
## Summary
He talks more about the creation of wealth and that technology has helped increase the income gap between the rich and the poor.
## Idea that surprised me
How the rich live more like the poor as a result of technology. Can't wrap my head around the implications of this notion.
## Unanswered questions
Whether corruption isn't as pervasive as he claims it to be in wealth countries.
## Objections/disagreements
His argument is fairly simplistic, especially the notion that the rich will always trickle down into more jobs and that rich people still work. Like much of this book, he simplifies an idea too much.
## Key takeaways
Whether increased variation in wealth is a good thing or not. Socialism is one thing, but such huge variations in income may or may not be beneficial to society.

# Chapter 8
## Summary
He discusses his statistical approach to spam filter based on context rather than looking at individual words and phrases.
## Idea that surprised 
That hie was fairly right about spam being eradicated. It obviously still exists but most major email services do a fantastic job at spam filtering.
## Unanswered questions
Why Graham is so opposed to "computer science" when his spam filtering technique is exactly the sort of idea many computer scientists work on.
## Objections/disagreements
None.
## Key takeaways
Statistical methods to solving problems have and will continue to be enormously important in the software industry.

# Chapter 6
## Summary
Graham discusses good design, the importance of simplicity in design, and how great design often arises from the work of others.
## Idea that surprised me
Just how much this essay reminded me of Apple. It could have been written by Apple internal: the focus on simplicity, iterating on previous ideas, making good design "slightly funny", etc.
## Unanswered questions
Whether good design really comes from "hotspots" or if it can arise from any source, especially in the Internet-age.
## Objections/disagreements
Ironically, he didn't focus on software design that much, and I would have liked his views on that.
## Key takeaways
Designing something to be simple and fun to use is hard.

# Chapter 10
## Summary
Graham discusses programming languages: machine language, high level languages, open source, and language wars. In addition, he touches on his dislike of object-oriented languages and his preference to dynamically typed languages.
## Idea that surprised me
That he can have a chapter called "Programming Languages Explained" be much shorter than I expected it to be. But mostly, that he was so down on objective-oriented languages.
## Unanswered questions
If the current explosion of languages is a good or a bad thing - is it creating too many compartmentalized programmers and apps?
## Objections/disagreements
None, really, except confusion over is OO take.
## Key takeaways
That is worth to know many languages, not just one.

# Chapter 11
## Summary
He discusses creating a programming language that would be the preferred language 100 years from now. He's quite focused on simplicity in the language, with very few structures creating a very orthogonal language.
## Idea that surprised me
That he didn't focus too much on parallel computing, as that's one of the big current questions in computer science. Focusing on how to do two things at once seems more important to me than reducing the number of features in a language.
## Unanswered questions
If Lisp is really all that he believes it to be.
## Objections/disagreements
None really, though I found this essay an odd mix of being both too basic and too esoteric.
## Key takeaways
I should take a look at Lisp (functional languages).

# Chapter 12
## Summary
This chapter is about Graham's belief that his choice of Lisp for his first web application contributed to the success of that app.
## Idea that surprised me
That he attributed so much of the success of his web application to the programming language used to create it. I feel that argument is backwards - a successful product can help to popularize a language, but a language would not help to popularize a product.
## Unanswered questions
Just why Lisp is so great, he spends oddly little time on it.
## Objections/disagreements
I think this overall argument is moot now. People can basically use any programming they want to solve any problem, except in certain cases when you have to rely on a certain SDK. Being good in a language and making and solid product is what matters, not the actual language itself.
## Key takeaways
Even if I'm doubtful of his argument, it's probably a good idea to have a functional language under your belt.

# Chapter 13
## Summary
This chapter again talks about Lisp and why it rocks.
## Idea that surprised me
First, I'm not sure why this was a separate chapter from chapter 12. But mostly, that Lisp is far more influential on modern languages than I had thought (such as lambdas and garbage collection). I had always thought C was the main driver of most modern day languages. 
## Unanswered questions
Whether it's worth learning the functional features of Lisp, or if that barrier to thinking in that manner is too high.
## Objections/disagreements
Shorter code isn't necessarily better. Generally it is, but making code too short and too simple can make it just as obtuse as longer code.
## Key takeaways
I really need to learn Lisp (or maybe Scala).

# Chapter 14
## Summary
Graham describes what he believes is the dream programming language: succinctness, hackability, can write programs quickly, easy to write libraries, and efficiency.
## Idea that surprised me
I'd be interesting to read more about the debate between having a fast profiler and rather making a statically typed language and thus making a faster compiler. Many companies (like Apple) are focusing on creating new compilers to replace aging giants like GCC, and I'm quite curious to learn more about this debate.
## Unanswered questions
What is his dream language? Lisp?
## Objections/disagreements
Computer languages are (oddly) intensely personal things, and ones dream language can differ from person to person.
## Key takeaways
I want to work on creating libraries and additions to a language that, for example, take good features from one language and bring them to another.

# Chapter 15
## Summary
Chapter discusses the differences between design and research, mostly the process of good design in making programming languages and software.
## Idea that surprised me
The idea of morale in design - that if you are bored when drawing something, the drawing will be boring. Being engaged while designing and creating things will not only make you happier but will actually lead to a better product, which is something I do not want to lose sight of.
## Unanswered questions
What the proper balance is between the Hail Mary strategy and starting small and iterating.
## Objections/disagreements
None, surprisingly.
## Key takeaways
Be happy when making stuff.