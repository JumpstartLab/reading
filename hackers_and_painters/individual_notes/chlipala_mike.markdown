CHAPTER 1

1) Summarize the chapter ( 1+ bullets )

- Paul discusses why school is a challenge for nerds. Ultimately, because school lacks any significant purpose, the whole system devolves into a popularity contest as a way to derive purpose from the system. But nerds see past this, and are already thinking about what they want to accomplish with their interests, so they don't participate in the game and end up at the bottom of the pyramid.

2) What was one idea the surprised or stood out to you? Why? ( 2-4 sentences )

I think his depiction of the school system is a bit dramatic and sensational. I disagree that schools and their inhabitants serve no purpsoe, and think many of these issues are being addressed in present-day school systems.

3) What was a question that you saw as unanswered? ( 1-2 sentences )

He doesn't present any alternatives. Instead, he almost resigns that this school system is inevitable in order for adults to accomplish other things. If he has kids, I wonder where they're going to school.

4) Did you have any objections or disagreements? ( 1-2 sentences)

- I think his argument is a little misdirected. I went to a public school, and I saw a lot of these things happen, but I believe there was a lot of good that came out of my time in the education system. It seems that kids were more vicious in his time.

5) What were your key take aways or things you want to remember? ( 1+ bullets )

- This chapter of the book makes a pretty good argument for private school, or at least specialized education. I think that could be a great way to combat these issues, but, speaking from experience, my time in school was hardly this dramatic (and I'd consider myself somewhat amongst the nerdier crowd).

CHAPTER 2

1) Summarize the chapter ( 1+ bullets )

- Hackers are makers, not necessarily "computer scientists." But our society likes to compartmentalize and label everything, so we lump them with computer science because it makes it easier to understand their intentions. This might be detrimental though, because hackers may suffer from an identity crisis if they feel they should be performing more "science."

Startups are a great place to learn to write good software. Big firms inherently need to decrease the "standard deviation" in an effort to avoid disasters, so this is limiting for hackers with potential. Big firms should encourage hackers to work on open source projects if they want to keep them intellectually active, or avoid them doing their own startup!

The best hackers have empathy for the people that will consume their software. That usually means understanding how little your users understand. Have empathy for readers too (the people who might ineract with the source code).

Hacking can be cool. We just have to do cool stuff with it.

2) What was one idea the surprised or stood out to you? Why? ( 2-4 sentences )

Academia judges hackers by their publications because it's easy, because the system "works" well enough and is generally accepted, despite being incredibly flawed. To measure hackers by their ability to design great software is very difficult.

Utimately, it seems that any "system" (academic evaluations, performance reviews, mortgage applications, etc.) designed to scale will soon become flawed. Once anything stops being difficult, you end up ignoring the details.

3) What was a question that you saw as unanswered? ( 1-2 sentences )

Unsurprisingly, Paul doesn't talk about any positives that may have come from lumping hackers in with computer science. Certainly, there has to be a few hackers that ended up in academia are making big moves there. Paul's entire argument is about having hcakers escape this computer science trap.

4) Did you have any objections or disagreements? ( 1-2 sentences)

"You should figure out programs as you're writing them, just as writers and painters and architects do." I think this is fine advice, and I think his intention is only to motivate us to get our hands dirty as soon as possible, but there's obviously an argument for the other side of this equation. I doubt that ALL writers, painters, and architects just randomly start working on an idea without any form of a plan (can you imagine an architect firm contracted to construct a building and starts designing without any semblance of a plan?)

5) What were your key take aways or things you want to remember? ( 1+ bullets )

"Hackers need to understand the theory of computation about as much as painters need to understand paint chemistry." I like reading this. For a long time I thought otherwise, and I think this reinforces my decision to do HA. In school, I dabbled in many different subjects, never leaning heavily towards math or science or english or the arts - I liked them all. But, when it came time to decide on a major, I rejected computer science for fear I lacked the requisite math knowledge and, for some time, accepted I could never "program". I'm finding that I fall into this hacker category - or I will soon enough. And my wide ranging interests may end up aiding me as a result.

CHAPTER 3

1) Summarize the chapter ( 1+ bullets )

- You should probably have opinions that some people would find contentious. People who don't inherently belive everything they're told. Question things, ideas, and fashions to both discover their origin and to ask if they make sense. The biggest source of moral taboos turn out to be power struggles where one side barely has the upper hand, giving the other side just enough power to question the idea.

Why do this? It's healthy for the brain, keeps you wise, and hopefully prevents you from being mistaken.

Be careful about who you express contentious views to, or you could get into trouble. Argue with idiots and you'll turn into one as well.

2) What was one idea the surprised or stood out to you? Why? ( 2-4 sentences )

This concept of asking questions seems to be prevalent in hacker culture, so it's interesting that he devotes a chapter to the practice of asking questions and being genuinely curious. 

3) What was a question that you saw as unanswered? ( 1-2 sentences )

In some ways, Paul's attitude of asking questions and being curious seems innate and can't quite be learned by someone. You have to possess this ability from the beginning or else this book would just seem like a load of pretentious crap. I'm not sure how he could have addressed this necessarily, but this chapter feels more like reinforcement than instruction.

4) Did you have any objections or disagreements? ( 1-2 sentences)

[Describing two cultures with opposing views on some particular taboo.] "My hypothesis is that the side that's shocked is most likely to be the mistaken one." This stood out to me. I want to agree with him, but there will obviously be exceptions. So, I'll say this is *mostly* true instead. Usually the shocked culture is the one afraid of change, or of approaching the argument from a new perspective. (That might actually be a better way to frame the argument instead of calling them "wrong." Would we say that anti-pedophilia people are "wrong"?)

5) What were your key take aways or things you want to remember? ( 1+ bullets )

Ask questions and be curious, but be wise in expressing your thoughts and opinions to others. Hacker culture seems to be a safe place to present dissenting ideas, but this is not true in every culture.

CHAPTER 4

1) Summarize the chapter ( 1+ bullets )

Hackers are champions of good ideas, and want to be in a place that fosters and promotes good ideas. This is why hackers are often so outspoken on many topics unrelated to computers. 

Those in a position to impose rules naturally want them to be obeyed. It seems our founding fathers had more in common with current-day hackers than current-day politicians.

2) What was one idea the surprised or stood out to you? Why? ( 2-4 sentences )

"It's odd that people think of programming as precise and methodical. Computers are precise and methodical. Hacking is something you do with a gleeful laugh."

I am certainly finding this to be true. I think this notion just stems from people's lack of familiarity with "hacking," so they believe what they've always believed. I'm confident this will change over time, but it will likely take a very long time.

3) What was a question that you saw as unanswered? ( 1-2 sentences )

Nothing really on this chapter.

4) Did you have any objections or disagreements? ( 1-2 sentences)

No. Very insightful.

5) What were your key take aways or things you want to remember? ( 1+ bullets )

Be curious about everything, not just computers. Good ideas need a community to foster their development.

CHAPTER 5

1) Summarize the chapter ( 1+ bullets )

Consumers want convenience above all else. Don't confuse them with pricing or words they don't have to know. Let the touch the service, make it easy to sign up, and you'll reap the rewards.

Web applications are unique in that releases can happen constantly, which drastically affects software development (this is particularly damming for desktop software that only pushes new releases periodically).

Web-based software should change how service providers approach support. At Paul's company, they wanted to hear from users to identify issues and fix them as soon as possible. Yahoo screwed this up though, as do most large companies.

Small teams are able to execute faster by identifying clear owners and holding them responsible in front of their peers. The lines are more blurry in terms of domain-responsibilities but there are big rewards for doing it this way.

Rich customers tend to want expensive solutions, regardless of whether it's actually a better solution.

Startups require an enormous amount of work, but the rewards are immense. And you can do it, and the big companies are afraid that you will!

2) What was one idea the surprised or stood out to you? Why? ( 2-4 sentences )

The brief topic on Support is interesting, because so few companies get this right. I strongly believe this notion should change in the future - support should sit with engineering teams always. As companies grow and compartmentalize various functions, the different departments stop working with each other. This means it takes longer for issues to be fixed and customers may inevtiably search for alternatives. This is why startups can disrupt big companies just on customer service alone, but as they grow they seems to get further away from this model. I also think it's an issue with engineering teams believing they're above customer service.

3) What was a question that you saw as unanswered? ( 1-2 sentences )

It would be interesting to see Paul reflect on this chapter today, as many of his predictions have come true. It's amazing how quickly this industry has moved in just a few short years. On top of that, I'd be curious to see his thoughts on starting and launching a company today versus what it was like a few years ago. I thinkg that if the same v1 services launched in 2005 were launched today, they wouldn't go anywhere. So, yes, while it's probably never been easier to launch a service today, it also requires the ideas to be more thought out and specialized in a lot of ways. In 2005 we needed basic collaboration tools, and today we're seeing a lot of press about companies launching payment platforms (Stripe, Square, etc. - arguably more specialized services).

4) Did you have any objections or disagreements? ( 1-2 sentences)

The chapter was a bit long-winded and some stuff felt outdated, but was interesting to see how his ideas have played out over the years regarding usage and collaboration of web-based software.

5) What were your key take aways or things you want to remember? ( 1+ bullets )

Do great things. I have the power to start and create something amazing. I am my biggest obstacle.

CHAPTER 6

1) Summarize the chapter ( 1+ bullets )

- If you want to get rich, a great way to do so is to join a startup. Money =/= wealth, and wealth is always being created. 
- People who recognize that wealth can be created are also people who good at making things themselves.
- "The best programmers are libertarians." You either sink or swim, no excuses.
- In large comapnies it is difficult to measure and reward contributions of employees besides salesmen and top execs. Because your work is averaged against other people in the company, rarely do people who work harder get rewarded for doing so.
- To get rich you need to be in a position where you're measured appropriately and you have leverage. If you're not famous or a CEO, this usually means working in a small group.
- The success of a startup depends on the first ten employees.
- New technology creates leverage. Big companies can do this, they just take forever.
- Startups aren't a guarantee though, there is a random factor associated with success and rewards.
- Look for hard problems.
- If you want to get bought, get users. Users are the only proof that you've created wealth - they've decided you have the best technology.
- Encourage entrepreneurs and everyone else wins.

2) What was one idea the surprised or stood out to you? Why? ( 2-4 sentences )

I've heard this essay referenced a few times in recent months but never got around to reading it. It's a fascinating, crystallized picture of why startups are important - and why you should join/start one. It's so emplowering to read this and see how simple it is to be rewarded for great work. It makes me sceptical of large companies in some ways, but moreso provides motivation to pursue great ideas.

It's interesting to think about startups not as some fad that has developed over the past decade or two, but rather a concept that has existed forever. In some ways, I've wondered if the startup phase will pass eventually, but it's clear how much startups add to our world and why they'll never disappear entirely.

3) What was a question that you saw as unanswered? ( 1-2 sentences )

Paul very briefly mentions how often startups fail. I'd be curious to see a longer-form discussion on what causes this because the essay seems to encouragae doing anything you can to join a startup. Obviously, the startup should have a great idea that you believe can succeed or else you're doomed to fail.

4) Did you have any objections or disagreements? ( 1-2 sentences)
5) What were your key take aways or things you want to remember? ( 1+ bullets )

I've only worked for large companies at this point, and will (hopefully) be joining another large company in a few months. I'm excited about my prospects, but it's clear I need to give startup life a shot.

CHAPTER 7

1) Summarize the chapter ( 1+ bullets )

- People tend to demonize the skill of making money, often because we confuse money and wealth.
- The free market determines what price people are willing to pay for different services. So what are we implying when we say some work is overpaid and some is underpaid? 
- Corruption in countries tends to die as easier ways to generate wealth become apparent. And when we see rich countries that are growing in income disparity, we tend to think they are becoming more corrupt - Paul argues those countries are, instead, a step ahead of corrupt countries.
- Technology may increase the income gap between rich and poor, but it seems to be decreasing the material and social gaps between these people.
- In a modern society (one absent of feudal-like corruption), increasing income variation is a sign of health.

2) What was one idea the surprised or stood out to you? Why? ( 2-4 sentences )

His argument about tehcnology closing gaps between rich and poor is absolutely true. Without technology, we would never have avenues like microfinancing to encourage entrepreneurship in poorer countries. Technology has been a powerful aid to poor people.

3) What was a question that you saw as unanswered? ( 1-2 sentences )

Paul talks a lot about the power of technology for all classes, but he seems to assume we all have the same access to technology, which is not true. Those without access suffer the most, and it makes upward mobility almost impossible. 

4) Did you have any objections or disagreements? ( 1-2 sentences)

I think Paul's argument about income disparity makes a lot of sense, but as with most of his arguments, there are a wide-range of exceptions once they are put into practice. In fact, I think most people would agree with his arguments regarding incentives for more specialized, in-demand, work. But, it assumes an almost unreasonable amount of compassion in the real-world - meaning people would never take advantage of others to generate wealth. The obvious flaw in this argument was the recent financial crisis...which I don't feel like going into detail on right now. In aggregate, technology may reduce corruption, but also presents immense rewards for those who use technology in corrupt ways

5) What were your key take aways or things you want to remember? ( 1+ bullets )

I'm struggling to identify a key takeaway here as this chapter has given me a lot to reflect on. Ultimately, I think it's important to think about income disparity and rewards/incentives as objectively as possible. But we have to put those theories into practice before we can make objective conclusions.

CHAPTER 8

1) Summarize the chapter ( 1+ bullets )

- We can use content-based filters to stop spam.
- Filter mail based on the spam and non-spam messages they receive. Construct the filter to respond to both non-spam and spam-based filtering (i.e., mark as spam or delete message)
- Bayesian filters will evolve with spam messages, so these are great mechanisms to prevent spammers using "tricks" to get past filters.
- But, many types of software working together will do more to prevent spam than just one content-based filters.

2) What was one idea the surprised or stood out to you? Why? ( 2-4 sentences )

- This essay was written in 2002, before most modern, web-based email services existed. It's interesting because this model of spam detection has been adopted widely, particularly with Gmail (although I'm not certain on the specifics of the spam filtering detection, the distinction between a 'Delete' and a 'Mark as Spam' button was interesting to see just as spam was becoming such a wide-reaching issue)

3) What was a question that you saw as unanswered? ( 1-2 sentences )

Again, I'd love a followup reflection considering how dated this essay is. Many spam-detection services are doing exactly as Paul has described and yet spam is still an issue. I'd be curious to get Paul's take on the issue today considering that it still hasn't been completely solved.

4) Did you have any objections or disagreements? ( 1-2 sentences)
5) What were your key take aways or things you want to remember? ( 1+ bullets )

Spam seems as thought it will be an issue for a long time to come!

CHAPTER 9

1) Summarize the chapter ( 1+ bullets )

- Good taste and good design are not just personal preference. The same principles of good design can be found everywhere.
- Good design: is simple, ia timeless, solves the right problem, is suggestive, is often slightly funny, looks easy, uses symmetry, resembles nature, is redesign, can copy, is often strange, happens in chunks, is often daring

2) What was one idea the surprised or stood out to you? Why? ( 2-4 sentences )

"The only style worth having is the one you can't help." I think this is an important concept. Inevitably, we'll end up copying and reusing the qualities of the people that inspire us, but all of those things combined define the style that we can't avoid. So rather than imitating your favorite hacker's coding style to the T, just take that inspiration and approach problems as you've always approached problems and you'll soon cultivate your own style.

3) What was a question that you saw as unanswered? ( 1-2 sentences )

Paul never really talks about how to cultivate great taste. There are certainly principles of great design, but his list just seems to be a lot of different concepts and examples of design. For someone who doesn't seem to possess "good taste" or design sense, I don't think that explaining that, "good design is simple" will suffice to help them understand why taste matters.

4) Did you have any objections or disagreements? ( 1-2 sentences)

I think Paul could have used more practical examples of how good design impacts everyone, particularly in the computer world. Apple is a fantastic example of a company who consistently approached design differently from other software and hardware companies. They're becoming a dominant force in the industry, and the exercise a lot of these principles, so a history and some examples here would have been interesting to consider for practical application of these principles.

5) What were your key take aways or things you want to remember? ( 1+ bullets )

Good design matters, and, above all else, good design is simple. 

CHAPTER 10

1) Summarize the chapter ( 1+ bullets )

- First came machine languages, then high-level languages that use a compiler to translate more readable code into machine language
- Open source code is a new model in that you have both the source and object code, and can effectively understand what the code is doing and even alter it if you need.
- Languages do differ, but it's hard to say which is the best.
- Big debate between languages that restrict what can be done and languages that don't, particularly in the concept of dynamic vs static typing
- We seem to be in an "Language Renaissance" in which new languages are being invented all the time.

2) What was one idea the surprised or stood out to you? Why? ( 2-4 sentences )

I was surprised by the simplicity of Paul's writing in this chapter. He's explaining concepts that took me a long time to grasp, yet I feel as though my mother could read this and have a good idea of how programming languages work. If anything, I was surprised by ability to crystallize the complex topics into just a few key points, effectively ignoring everything that can make these topics so confusing.

3) What was a question that you saw as unanswered? ( 1-2 sentences )

I would have liked to see Paul's take on the language renaissance written in more detail. He's obviously a Lisp enthusiast, but I'd like to have seen what he saw as a great emmerging language from this renaissance and why.

4) Did you have any objections or disagreements? ( 1-2 sentences)
5) What were your key take aways or things you want to remember? ( 1+ bullets )

It would seem unwise to limit myself to just one language. Given the plethora of open source languages at my disposal, I have much to learn.

CHAPTER 11

1) Summarize the chapter ( 1+ bullets )

- We should want to know what languages people will program in 100 years from now, so we can make bets on the languages that will lead to those future languages.
- There is good waste and bad waste. Good waste is where we can spend more and get simpler designs.
- Innefficient software isn't gross. What is gross is a language that makes programmers do needless work.
- Data structures may be flattening; maybe we should get rid of strings in favor of lists?
- OO programming might not offer that much to good programmers, it just works well for big organizations.
- How to design the language that we want to write? Well, assume infinite resources and just write down whatever would be easiest.
- The hundred year language could, in principle, be designed today and people might actually want to program in it.

2) What was one idea the surprised or stood out to you? Why? ( 2-4 sentences )

Paul's concept of the 100 year language seems to be prevalent in some of the web frameworks that are being released. Rails and Django do a lot of thes behind the scenes work he's discussing, and node.js allows for some of the parallel processing concepts that he's mentioning as well. So, in fact, it may be that this language does exist today!

3) What was a question that you saw as unanswered? ( 1-2 sentences )

I would have loved to see a more in-depth analysis of present-day languages, outlining in specifics why they likely won't be considered the 100-year language. Alternaively, highlighting some cutting-edge languages that are pushing the envelope would have been an interesting topic to read.

4) Did you have any objections or disagreements? ( 1-2 sentences)

Not at all. I think this was a great chapter.

5) What were your key take aways or things you want to remember? ( 1+ bullets )

Basically, do everything with an eye to the future. Whether it's language design or something completely different, take into account how it we'll use it 1 year, 10 years, or 100 years from now.

CHAPTER 12

1) Summarize the chapter ( 1+ bullets )

- When Paul started Viaweb, they chose to program in Lisp, which was uncommon at the time, but allowed them to develop at a rapid pace that their competitors couldn't match.
- Programming languages vary in power. When given a choice between languages, use the most powerful one.
- Only programmers in a position to to see all the differences in power between the various languages are those who understand the most powerful one.
- The median programming language moves very slowly - use this against your competitors.

2) What was one idea the surprised or stood out to you? Why? ( 2-4 sentences )

I like the point about using the rate at which the programming community adopts new languages against your competitors. I think the hacker community has realized this in recent years, and it seems that many developer jobs today empower developers to use whatever language they need to get the job done. Web companies today move at an incredible pace.

3) What was a question that you saw as unanswered? ( 1-2 sentences )

Paul seems to imply both that Lisp is the most powerful language (at the time this essay was written), and that only Lisp programmers can understand why it is the most powerful language. This is interesting because it seems the hacking community never really took to Lisp like it has to Python (a language he calls out specifically as not having to worry about as much) and other languages. 

4) Did you have any objections or disagreements? ( 1-2 sentences)

I addressed them somewhat in the last question. It's just interesting that despite Paul's confidence in the power of Lisp, it never really reached mass adoption like other languages have.

5) What were your key take aways or things you want to remember? ( 1+ bullets )

Use the right tool for the job.

CHAPTER 13

1) Summarize the chapter ( 1+ bullets )

- Not all programming languages are equal. Be wary of the pointy-haired boss that does not understand technology, yet seems to have very strong opinions on it.
- Lisp was originally developed as a "theoretical exercise" until one of John McCarthy's grad students programmed a Lisp interpreter to actually functiona as a programming language.
- Lisp was the first language to support many new concepts such as: conditionals, recursion, dynamic typing, garbage collection, and the whole language available at all times.
- Lisp's use of macros gives Lisp unique power and advantages over other languages. At the time, no other languages have an equivalent.
- Choosing to develop in a more powerful language may reduce the size of your team because you won't need to hire as many hackers, and hackers working in more powerful languages are probably smarter.
- Don't let VCs or potentials acquirers design your product. Design the product to please users and everything else will follow.
- More powerful languages require less work to write the program.
- If you want to win in technology, pick the hardest problem and the most powerful language to solve it with.

2) What was one idea the surprised or stood out to you? Why? ( 2-4 sentences )

Ruby seems to possess much of the power that Paul loves about Lisp :)

3) What was a question that you saw as unanswered? ( 1-2 sentences )

I don't think Paul is presenting anything too contentious here: use the most powerful tool to get the job done. But, the vast majority of the time, this assumes that there are no other factors at play to influence your decisison, which almost never the case in the real world. It would be interesting to see how Paul could make the argument for migrating to Lisp in a big organization, or how to advocate for Lisp in an organization that seems stuck in the past. Without more practical examples of how to make Lisp work for everyone, it will only ever be a language used by the few.

4) Did you have any objections or disagreements? ( 1-2 sentences)

Not really, would just love to see more practical applications of Lisp beside Yahoo Stores and ITA Flight search software.

5) What were your key take aways or things you want to remember? ( 1+ bullets )

The theme here has been consistent in the past few chapters: use the most powerful tool to solve the problem. There will obviously be trade offs, in which case you can't do this, but when there's a debate of one language against another, always pick the powerful one if you can.

CHAPTER 14

1) Summarize the chapter ( 1+ bullets )

- The most important force that determines relative popularity of a programming language over a long period of time is the opinion of expert hackers.
- External factors determine the popularity of a language. This usually means the language has to be the scripting language of a popular system.
- Good languages need to be succinct, because hackers are lazy.
- A good language also needs to be hackable - don't assume how users will consume the language, let them do what they want.
- Good languages should allot for many throwaway programs - hackers want to test it our quickly or else they'll move on to something better.
- An extensive library collection allows anyone to pick up the language and quickly begin using it.
- A good language has to be efficient in how it generates the code.
- A language has to be around for some time before people will full trust it.
- Redesign is good and don't be too skeptical of your own work.

2) What was one idea the surprised or stood out to you? Why? ( 2-4 sentences )

Paul talks about two ways to introduce technology and gain users: the big-bang method and organic growth. He argues that organic growth often yields better technology and richer founders. This is interesting considering that Paul runs a VC-firm that seems to put a lot of emphasis on big-bang introductions (or maybe I'm just not hearing about as many of the organically grown comapnies). Organic growth may be better longer-term, but for a VC that wants faster returns, big-bang introductions might be preferable. I'd be curious to hear Paul's opinion on this today.

3) What was a question that you saw as unanswered? ( 1-2 sentences )

I'd like to see where Lisp has failed in these tenants of a dream language.

4) Did you have any objections or disagreements? ( 1-2 sentences)

Absolutely not.

5) What were your key take aways or things you want to remember? ( 1+ bullets )

- It seems as though we're getting closer to Paul's concept of a "dream language." In many ways, Ruby possesses these qualities (particualy the extensive and accessible libraries) and we may get there sooner than later, although I doubt a language will ever be perfect.

CHAPTER 15

1) Summarize the chapter ( 1+ bullets )

- When you focus on the user, you treat programming languages as a design problem instead of a research topic.
- Recognize that users might not always know exactly what they want, but they are the ultimate measure for the value of the product you've produced.
- Don't look down on your users or you'll end up making a bad product. Produce as much for yourself as for your users.
- The test of a language is not simply in how pretty the finished product is, but how clean the path to get to that product was.
- Keep close to your users - "worse is better." Get a prototype in front of users.
- Morale is key in design, and this usually means having a clear picture of the end goal, so always have working code.

2) What was one idea the surprised or stood out to you? Why? ( 2-4 sentences )

Morale being influenced by working code is important. I can think of countless examples of being demotivated because I didn't know what I was working for. By setting goals, prototpying, and executing quickly you can keep morale boosted and ultimately put out a better product.

3) What was a question that you saw as unanswered? ( 1-2 sentences )

Ultimately, the balance between designing for you and designing for users is a delicate one. Spending too much time on revising a working prototype may delay a project too long, but you obviously need to be receptive the asks of your users. I'm certain that people have written books on this topic, but it felt like there could be more discussion on this topic.

4) Did you have any objections or disagreements? ( 1-2 sentences)

No. I thought this was a fantastic chapter.

5) What were your key take aways or things you want to remember? ( 1+ bullets )

Love what you do, or else it will be worthless - to you and your users.