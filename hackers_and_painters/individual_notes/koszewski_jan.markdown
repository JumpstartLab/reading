# Chapter 1:

## Summary    
    
* nerds are unpopular in high school, not because they don't want to be, but because they care more about being smart and pursuing higher intellectual goals than being popular.

## What Stood Out

* school is equivalently a prison, or at the tamest, a holding center for young kids
* teenagers/children are cruel by nature

## Questions Unanswered

* none

## Objections

* i don't think that kids are generally THAT cruel, though my memory is foggy. moreover, i disagree with the notion that nerds can't or won't be popular if they don't want to, or that they will be subject to ostracization and punishment from other children, particularly in high school.  i think that the smartest nerds or children can simultaneously achieve a level of popularity that will insulate them from ostracization or bullying but also allow them to achieve their intellectual goals.  i don't believe it's a zero-sum game and i fundamentally believe that nerds, with their unfathomable intelligence CAN navigate the social turmoils of school if they so choose to do so.

## Takeaways

* paul graham seems really, really bitter

---

# Chapter 2: 

## Summary

* hackers are like painters in that they're both "makers" - unlike scientists, mathematicians or other people who work in the more "traditional" roles in computer science

## What Stood Out
> "a great painting has to be better than it has to be" - _Paul Graham_
* the idea that the pursuit of good code is all-consuming.  i agree thoroughly in retrospect, but it's a lesson that i don't think i've yet taken to heart
* leaving bugs for debugging later as you settle into off and on cycles of development
* the battle for innovation is in untested or unclaimed markets, not necessarily within existing castles

## Questions Unanswered
* none 

## Objections
* i have a small contention with the idea that you can't take on microsoft - i think that you can catch larger companies in areas where they're slacking or find holes in their existing software and models and pounce on those as well, not just in emerging or new markets

##Takeaways 
* the pursuit of good code is all-consuming
* have a side project, or something that keeps you hacking outside of your "day job"
* if you want to write truly good, new, or innovative code, start something

---

# Chapter 3: 

## Summary

> "how can you see the wave, when you're in the water?...always be questioning" - _Paul Graham_

## What Stood Out

> "the most important thing is to be able to think what you want, not say what you want" - _Paul Graham_

> "as fashion becomes more established, they'll be joined by a second, much larger group, driven by fear.  this second group adopts fashion not because they want to stand out but because they are afraid of standing out." - _Paul Graham_

> "i think many interesting heretical thoughts are already formed in our minds. if we turn off our self-censorship temporarily, those thoughts will be the first to emerge" - _Paul Graham_

> "in one culture x is okay, and in another it's considered shocking.  my hypothesis is that the side that's shocked is most likely the side that's wrong." - _Paul Graham_

## Questions Unanswered

* what are paul's radical ideas?  he seems to encourage their exploration, but refuses to espouse many of his own (at least in this chapter)

## Objections 

* none

## Takeaways
* keep questioning, question everything, as objectively as you can

---

# Chapter 4:

## Summary

* "Hackers" have a penchant for disregarding authority, and that penchant in and of itself is a good thing because it's how we best learn or innovate on something old

## What Stood Out

> "they may laugh at the CEO when he talks in corporate newspeech, but they also laugh at someone who tells them that a certain problem can't be solved.  suppress one and you suppress the other" - _Paul Graham_

> "the reason that Florence is famous is because in 1450 it was New York.  in 1450 it was filled with the turbulent and ambitious people you now find in America.  (so i went back to America)" - _Paul Graham_

## Questions Unanswered 

* none

## Ojections

* i think that his insistence on the sacredness of the word "hacker" is a little bit disturbing, and far-reaching, as well as his affinity for using the term "hacker" to seem to encompass all hackers'/developer's/programmers' mindset, ethos, and overall life opinion as unified

## Takeaways

* if you're going to disobey authority, do it in a way that doesn't disrupt your hacking

---

# Chapter 5:

## Summary

* the future of software and software development is server-based software written to be accessed by users in a web browser.  this type of software is cheap to produce, easy to implement and something that can be tackled faster by small groups and individuals than it can by large companies

## What Stood Out

> "software has to be implemented by hackers who understand design, not designers who know a little bit about software" - _Paul Graham_

> "a big part of what large companies pay extra for is the cost of selling expensive things to them" - _Paul Graham_

> "the test drive was the way that we got nearly all of our new users. i think it will be the same for most web-based applications." - _Paul Graham_

> "investors and analysts would ask us what we had planned for the future. the truthful answer would have been, we don't have any plans. we had general ideas about things we wanted to improve, but if we knew how, we would have done it already." - _Paul Graham_

> "software companies are sometimes accused of letting users debug their software.  and that's just what i'm advocating" - _Paul Graham_

## Questions Unanswered 

* the exploration of the fluctuation from mainframe to desktop to server-based software and computing model wasn't nearly as fleshed out or thorough as i'd hoped it'd be; he seemed to chalk it entirely up to visicalc, which seems a little bit short-sighted.  i also think that there IS still a place for desktop software that he's ignoring, or at least that he's glossing over a lot of people's objections to the "cloud" or the server-based model.  i can't say that i uphold those objections, but i think that delving more into why those paradigms still hold true is at the least a good idea if you're truly going to reach people like his mother and convince them that they DON'T need anything but the software you provide them with a web-browser

## Objections

* i was/am a little bit wary that the entirety of what paul's advocating seems to be predicated on his time at or with Viaweb.  we got snapshots of his comparative experience working at other companies, but it seems like this chapter is focused entirely on the successes of Viaweb and little more.  i don't disagree with the model he's espousing outright, but it's hard for me to necessarily take the lessons of one data point (even if said data point was extremely successful) as verboten law

## Takeaways

* web/server-based software is the future, at least according to graham
* start small and scrappy, and be prepared to sink your life into it

---

# Chapter 6:

## Summary

* the creation of wealth is inherently the creation of something that other people want, and that pursuit of wealth itself drives innovation and technological advancement

## What Stood Out
> "the answer may be that Europeans rode on the crest of a powerful new idea: allowing those who had a lot of money to keep it" - _Paul Graham_

> "for potential acquirers, the most powerful motivator is the prospect that one of their competitors will buy you. the second biggest worry is that if they don't buy you now, you'll continue to grow rapidly and will cost more to acquire later, or even become a competitor" - _Paul Graham_

> "if you can develop technology that's simply too hard for competitors to duplicate, you don't need to rely on other defenses" - _Paul Graham_

> "to get rich you need to get yourself in a situation with two things: measurement and leverage...if you're in a job that feels safe, you're not going to get rich because if there is no danger there is almost certainly no leverage" - _Paul Graham_

## Questions Unanswered

* none 

## Objections

* this all seems to be pushing a fairly libertarian agenda, or at the least encouraging the pursuit of commercial ends that do not satisfy a need or belief in a greater "public" good.  not that there's much wrong with that for a book or perspective geared towards the idea of writing commercial software.  just observing.

## Takeaways

* wealth is simply what people want
* in order to be put in a position where you control the amount of wealth you want to attain or would like to create, you need leverage and measurement

---

# Chapter 7: 

## Summary

* let the wealthy keep their wealth; variation or disparity in income can be as much of an indicator of societal (or at least entrepreneurial) health as it is of societal ill

## What Stood Out

> "i'm not saying that if you let Henry Ford get rich that he'll hire you as a waiter at his next party.  i'm saying that he'll make you a tractor to replace your horse" - _Paul Graham_

> "i'd like to propose an alternative idea: that in a modern society, increasing variation in income is a sign of health.  technology seems to increase the variation in productivity at faster than linear rates"

> "technology has made it possible to create wealth faster than you could steal it" - _Paul Graham_

## Questions Unanswered

* are multi-million-dollar CEO's and athlete's really being accurately compensated for the "wealth" they generate?  i suppose that they are given a true market economy, and i suppose that my perception of what value sports or certain companies bring to society also clouds my judgment there

* the underlying argument for variation in wealth also seems to be predicated on the idea or assumption that all people have the same or equal opportunity to pursue or achieve the creation of wealth as everyone else does

## Objections 

* again, this seems to be pushing an awfully libertarian agenda. i don't disagree with any of the basic underlying arguments re: wealth generation or the basic reward to people for the services they provide or the wealth that they create, i think it's just farther out in left field than i'm normally comfortable with, more so with respect to my second bullet above in section 3.  i'll accept graham's basic argument that the variation of income or variation of wealth is by and large acceptable and indicative of a "healthy" society, but i think that he needs to critically address the issue of access to opportunity before he can stand on his soapbox and justify the retention of wealth at the cost of purposefully disadvantaging others

## Takeaways

* let the wealthy keep their wealth

---

# Chapter 8: 

## Summary

* Bayesian filters are the best spam filters available
* reducing the efficacy of spam as a marketing tool overall will reduce the amount of spam sent to the point where spammers will have to engage in "legitimate" business in order to remain profitable  

## What Stood Out

> "i used to think it was naive to believe that stricter laws would decrease spam. now i think that while stricter laws may not decrease the amount of spam that spammes send, they can certainly help filters to decrease the amount of spam that recipients actually see." - _Paul Graham_

> "result: if it can't contain exciting sales pitches, spam becomes less effective as a marketing vehicle, and fewer businesses want to use it." - _Paul Graham_

## Questions Unanswered

* none

## Objections

* why is this chapter here, in the middle of what felt like a natural narrative progression based on the previous two chapters?  it felt very weird and out of place, most like graham was taking a narrative or mental break before recomposing his next thoughts - or trying to pitch a new business idea

## Takeaways

* eliminate the efficacy of spam and you eliminate spam altogether
* use a bayesian spam filter


---


# Chapter 9:

## Summary

* good design stems from good taste; taste in turn is an evolving process and one that can't be forced or perceived as "good" until one has a achieved a significant amount of practice and experience 


## What Stood Out

> "but if your job is to desing things, and there is no such thing as beauty, then there is no way for you to get better at your job" - _Paul Graham_

> "when you're forced to be simple, you're forced to face the real problem.  when you can't deliver ornament, you have to deliver substance" - _Paul Graham_

> "the danger of symmetry, and of repetition especially, is that it can be used as a substitute for original thought" - _Paul Graham_

> "...I don't think it works to cultivate strangeness.  the best that you can do is not to squash it if it starts to appear" - _Paul Graham_


## Questions Unanswered

* how do you actually ACQUIRE taste?  i threw in my personal summation about acquiring good taste through significant amount of practice and experience under section 1 because i was projecting - graham makes a lot of prescriptions about what good taste or form IS, but doesn't actually describe how to go about achieving it


## Objections

* a lot of this chapter is incredibly assertive without throwing a lot of substance or objective proof behind the inherent argument about what 'good' design or taste necessarily is.  

## Takeaways

* good design is elegant, simple, emergent, and thorough.  but i'll be damned if i know how to go about achieving it - you'll know it when you know or see it


---

# Chapter 10:

## Summary

* there are a multitude of programming languages available to programmers to use today, and most program in a high-level language that uses a compiler or interpreter to talk to the computer in assembly or machine-language

## What Stood Out

> "for the little, everyday problems that programmers spend so much of their time solving, libraries are probably more important than the core language. and so these odd hybrids are quite useful, and become correspondingly popular" - _Paul Graham_

## Questions Unanswered

* what are the reasons for programmers/hackers using the languages they do?
* which languages are the most accessible from a learning perspective?  
* which ones are most pervasive in the industry/each industry?  
* how does one actually go about writing a new language, and why would one do that, given the languages and libraries available to programmers today?

## Objections

* another weird and substantively brief chapter. i feel like paul's taking breaks between getting up and down from his pulpit

## Takeaways

> "so it is probably good that programmers live in a post-Babel world.  if we were all using the same language it would probably be the wrong one" - _Paul Graham_

---


# Chapter 11:

## Summary

* in the realm of programming language design, design for the future, as it's within our realm of possibility

## What Stood Out

> "the trend is not merely toward languages being developed as open source projects rather than "research", but towards languages being designed by the application designers who need to use them, rather than by compiler writers" - _Paul Graham_

> "could a programming language go so far as to get rid of numbers as a fundamental data type?" - _Paul Graham_

> "SUVs are gross they're the solution to a gross problem (how to make minivans look more masculine)" - _Paul Graham_


## Questions Unanswered

* what distinguishes a compiler from the language?
* how do you go about writing or creating a new language?
* how do you go about writing or creating a compiler?
* can existing languages be augmented more so by re-writing the compiler as opposed to the language itself?
* is there anything to be said for increasing language interaction now?  or is that a pipe dream/dead end?

## Objections

* purposefully designing a language for implementation or use in one-hundred years seems to be at odds with the espousal of the "emergent" ethos of software development and beauty that graham has previously professed
* i fundamentally don't believe that we have the capacity right now to produce a programming language that will survive or become the 'Hundred-Year' programming language - technology will shift too radically in 100 years for us to anticipate and build that far into the future right now

## Takeaways

* though we might not necessarily be able to design the hundred-year language now, we shouldn't let that hold us back from trying


---

# Chapter 12:

## Summary

* in order to stay ahead of the competition, always be on the cutting edge of new technology; also, Lisp is the most powerful programming language because it has macros

## What Stood Out

> "so, if you're running a startup, you had better be doing something odd. if not, you're in trouble"

> "no one was leaking news of their features to us. we were just able to develop software faster than anyone thought possible"

> "i'll begin with a shockingly controversial statement; programming languages vary in power"

> "in a competitive situation, that's an advantage. Lisp's power is multiplied by the fact that your competitors don't get it"

## Questions Unanswered

* how much are you biased towards lisp because it's what you know and use?  are macros necessarily all that revolutionary in a programming sense?

## Objections

* i don't think that i have a solid enough programming background to thoroughly and equivocally comment on Graham's praise of Lisp...though I feel like I _should_ at an objective level

## Takeaways

* learn Lisp
* continuously expose yourself to the new things in your field or at least do your best to stay on top of them as much as possible

---

# Chapter 13:


## Summary

* software languages are multitudinous in their use and implementation, but some are more powerful to use than others.  the distinction between languages and certain language's strengths over others is, however, generally not understood well enough by corporate bosses/managers, or people outside of the "hacking" community
* Lisp is the best and/or most advanced software language ever created, the evolution of all other programming languages tend towards it

## What Stood Out

> "it may also be because if you do add that final increment of power, you can no longer claim to have invented a new language, but only a new dialect of Lisp" - _Paul Graham_

> "but if you control the whole system and have the source code of all the parts, as ITA presumably does, you can use whatever languages you want. if any incompatibility arises, you can fix it yourself" - _Paul Graham_

> "if you start a startup, don't design your product to please VCs or potential acquirers. _design your product to please the users_. if you win the users, everything else will follow. and if you don't, no one will care how comfortably orthodox your technology choices were." - _Paul Graham_

> "when i see patterns in my programs, i consider it a sign of trouble.  the shape of a program should reflect only the problem it needs to solve. any other regularity in the code is a sign, to me at least, that i'm using abstractions that aren't powerful enough - often that i'm generating by hand the expansions of some macro that i need to write." - _Paul Graham_

## Questions Unanswered

* is Lisp truly the pre-eminent solution to all programming or software writing problems?
* is the pointy-haired boss truly endemic and the only paradigm of middle manager in the software development industry?  how does Graham know that the mythic boss ISN'T pointy-haired and just as much a nerd as him, if not more so?

## Objections

* the only concrete proof of Lisp's greatness that Graham offers up is its simplicity to construct and/or write a single incrementation function; more abstractly, he claims that the least amount of code written is paramount above all else and offers up statistics even he can't verify regarding the dominance and power of Lisp over other languages.  he's not objectively approaching this issue, and it feels to me like a lot of fluff or hot air (especially as a novice or someone approaching programming with very little to no prior experience).  is Lisp really the ideal candidate for all solutions or implementations?  is the non-accessibility of Lisp somehow NOT a barrier to its pre-eminence?  if it truly is the end-all, be-all, why isn't it more widespread?

## Takeaways

* Lisp is the pre-eminent solution to everything programmatically, according to Graham
* Graham hates middle-managers and/or non-nerds

---

# Chapter 14:


## Summary

*

## What Stood Out

> "i think a language has to be popular to be good. and it has to stay popular to stay good." - _Paul Graham_

> "a language also needs to have a book about it. the book should be thin, well-written, and full of good examples. Kernighan and Ritchie's _C Programming Language_ is the ideal here.  at the moment i'd almost say that a languages has to have a book published by O'Reilly. that's becoming the test of mattering to hackers." - _Paul Graham_

> "and so, paradoxically, if you want to make a language that is used for big systems, you have to make it good for writing throwaway programs, because that's where big systems come from" - _Paul Graham_

## Questions Unanswered

*

## Objections

*

## Takeaways

*

---

# Chapter 15:


## Summary

*

## What Stood Out

> "a good architect, for example, does not begin by creating a design that he then imposes on the users, but by studying the intended users and figuring out what they need" - _Paul Graham_

> "and looking down on the user, however benevolently, always seems to corrupt the designer" - _Paul Graham_

> "but one of the main ideas in that mix is that if you're building something new, you should get a prototype in front of users as soon as possible" - _Paul Graham_

> "more is key in design. i'm surprised people don't talk more about it" - _Paul Graham_

## Questions Unanswered

*

## Objections

*

## Takeaways

*