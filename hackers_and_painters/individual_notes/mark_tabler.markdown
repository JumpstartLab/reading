# Why Nerds are Unpopular
    ### Summary
    Nerds do better in a meritocracy
    
    ### Surprising Idea
    That schools are valueless except as holding pens for children. That teenagers are "useless, except as cheap labor in industries like fast food."

    ### Unanswered
    If the problem is just that nerds don't put as much effort into being popular as they do other endeavors, then why are there so few popular nerds? If it's a skill that can be practiced like any other, why are the split so polarized?

    ### Objection
    I disagree with the points about schools being useless; certainly there is room for improvement but I think the author would find a dramatic difference between students who complete their primary education and those who don't attend at all.

    ### Key Takeaways
    
    * Rebellion is an effect of wanting to distance oneself from the values of a particular group.
    * Being liked and being skillful, while not mutually exclusive, are two completely separate paths to success.

# Hackers and Painters
    ### Summary
    Hackers are more like artists than scientists.

    ### Surprising Idea
    Computer science is too broad an umbrella term. Hackers and the kinds of people who write software for financial institutions and hospitals are so far different that they should actually have different terms for each.

    ### Unanswered
    Should hacking be taught in universities at all? Should there be a Bachelor of Arts as well as a Bachelor of Science for computer programming?

    ### Objection
    A minor nitpick, but I find that certain problems *are* better solved on paper before one gets to a computer. As I constantly remind myself, it's far better to establish what the API should look like on paper first, then start "code-sketching" the methods to support that API.

    ### Key Takeaways
    * To do good work, you have to take the inspiration cycle into account.
    * Debugging, to some, is "as relaxing as painting a wall."
    * Divide projects into sharply defined modules, each with a definite owner.

# What You Can't Say
    ### Summary
    You should think about what you can't say in polite society, and form your own opinions about it.

    ### Surprising Idea
    That if you think the same things as everyone around you, then it's because you only think what you're told. "It would be like... everyone claiming they had independently decided in 1972 that bell-bottom jeans were a good idea."

    ### Unanswered
    Is it necessarily true that the ability to think shocking thoughts correlates to the ability to think original ones?

    ### Objection
    I think that there are many circumstances in which a collection of members in a society can arrive at the same culturally-unique conclusion independently. Believing the same thing as your peers doesn't necessarily mean that you think what you're told, it could mean that you have a similar pool of experiences to draw from.

    ### Key Takeaways
    * Take no thought for granted. 
    * Understand why you believe what you believe.

# Good Bad Attitude
    ### Summary
     Hackers often break the rules, but in a way that should be acceptable.

    ### Surprising Idea
    If you suppress the ability to think that someone is being ridiculous, you also suppress the ability to think that nothing is impossible.

    ### Unanswered
    Is the fact that something can be done really a moral justification for doing it?

    ### Objection
    I disagree largely with the entire chapter. It's quite possible to be intellectually curious and maintain a healthy respect for society's rules and laws. I don't advocate blindly following leadership, but I don't think that means having to disregard law as a whole.

    ### Key Takeaways
    * Some hackers don't mind giving the culture a reputation for lawlessness.

# The Other Road Ahead
    ### Summary
    Web coding is the same kind of frontier that personal computing was in its genesis.

    ### Surprising Idea
    "What's scary about Microsoft is that a company so big can develop software at all. They're like a mountain that can walk." It seems odd that size becomes a disadvantage, but upon reflection I find that I can see the point.

    ### Unanswered
    Does it work to have a large company broken into small enough units that they can operate as discrete silos? If I have an isolated team of four programmers who only report to one project liason, is that the same as having an entire company of four programmers and one business-thinker?

    ### Objection
    In point of fact, there is more to know about running a business than "make more than you spend." The Penny-Arcade guys, who almost lost their company a decade ago, can attest to the fact that having some business acumen on your side can be a make-or-break difference.

    ### Key Takeaways
    * Somebody out there is making a kickass startup right now. Why isn't it me?
    * In every era, there is a frontier of unexplored territory; the web app environment is one of ours.

# How to Make Wealth
    ### Summary
    There is a difference between earning money and making wealth; you want to do the latter.

    ### Surprising Idea
    That given enough multiplicative modifiers, you could be (for example) 36 times more productive than you're expected to be in a random corporate job. I'm not sure that I could create the same value in one hour that I did in a workweek at any of my previous jobs.

    ### Unanswered
    What on Earth happened with the licensing deal for DOS that made Gates a billionaire? That knowledge is not universal enough knowledge to have gone without a word of explanation.

    ### Objection
    I'm not convinced about the absolute separation of wealth and money. It seems that if I'm in an isolated group of 100 people, and 20 of them want bicycles but only 15 can afford them, and I have the capacity to make 20 bicycles, then my ability to create wealth and my ability to earn money are two separate numbers. I just don't know how that scales to economies of national scale.

    ### Key Takeaways
    * In a small enough group, you can get paid for what you add to the team rather than for being a warm body.
    * Startups are a way to take the value of your output and wager it in a fair-odds casino.

# Mind the Gap
    ### Summary
    Distribution of wealth can be unequal without being unfair.

    ### Surprising Idea
    That a CEO is actually worth 100 times an editorialist (for example). In some way or another it has to be true, otherwise CEOs would not be as highly paid as they are; the only reason I can think of that anybody would *want* to be in charge of so much is because the compensation is quite substantial.

    ### Unanswered
    What does a person (CEO or otherwise) have to do in order to be worth 100 times an "ordinary" employee? Specifically, beyond working hard and being smart, what should *I* do to be worth 100 times the person sitting next to me?

    ### Objection
    I think that there are some pieces where the disparity of wealth between people of dissimilar skillsets can be unjust. I absolutely believe that public school teachers should receive a better salary than bank managers on purely moral grounds.

    ### Key Takeaways
    * A farmer with a tractor is 6 times as productive as one with a plow - if he masters a new kind of farming.
    
# A Plan for Spam
    ### Summary
    Probability-based filtering of spam is remarkably effective.

    ### Surprising Idea
    Nothing in this article was particularly shocking or surprising to me.

    ### Unanswered
    So.... why hasn't he written and distributed this solution? Why can I not, right now, buy this off the shelf (or subscribe to a service that provides it?)

    ### Objection
    I have no objections to anything in this article. It does feel very out of place from the rest of the book so far
    philosophy, philosophy, philosophy, practical solution to a technical problem, philosophy, philosophy....

    ### Key Takeaways
    * Probability: it works.

# Taste for Makers
    ### Summary
    Taste is a skill that can be improved, like any other.

    ### Surprising Idea
    The concept of the Milanese Leonardo caused me to stop and contemplate the implications of that for a while. Who else have we missed out on for all the wrong reasons?

    ### Unanswered
    What is it about Florence that was not true about Milan that made Leonardo? How do we make a 2012 Washington DC that produces the world's best Rubyists?

    ### Objection
    I still think that taste is subjective, and that "improving" ones taste very closely correlates with "anticipating what more people will like". Sometimes I suspect it's "anticipating what thought leaders or conoisseurs will like".

    ### Key Takeaways
    * Maybe you can do great work away from the focal point of your field - but the Milanese Leonardo couldn't.
    * There is no permanent place for ugly things in mathematics. Or, presumably, in computer science.

# Programming Languages Explained
     ### Summary
    Exactly what it says on the tin
    an explanation of what a programming language is and how it works.

     ### Surprising Idea
    While the author didn't touch on this directly, he seemed to imply that an operating system written in a high-level language is feasible. It would be an interesting thought experiment to figure out where Ruby would have trouble being an operating system; it might never be fast but it would certainly be extensible.

     ### Unanswered
    This chapter seemed to be more about answering questions than raising them. 

     ### Objection
    "Surely a language that lets you do x is at least as good as one that forces you to." I don't think that's entirely true, and find it symptomatic of the author's dismissiveness toward rules in general. Sometimes it's nice to know that everything I can possibly deal with in a language will conform to X standard, as opposed to merely being aware of X option.

     ### Key Takeaways
    * If you use a language for long enough, you start to think in it.

# The Hundred-Year Language
     ### Summary
    Using programming languages that are likely to be antecedants of future languages is a good heuristic for figuring out if you're using the best languages of our time.

     ### Surprising Idea
    I'm kind of surprised that the author is casting his predictions about future programming languages in terms of compiler optimizations. To me, the concept of manually setting compiler directives is already kind of archaic; I think that there's going to be a lot less compiled software and a lot more interpreted.

     ### Unanswered
    Why is it inherently better to be near the middle of the evolutionary branch? I can think of a number of tools that are very specific to a problem of its era that are quite efficient at what they do and that will never spawn a descendant. I don't say that it's always better to select the specialized tool, but I'm hardly convinced that the converse is true.

     ### Objection
    I think that object-oriented programming offers plenty to a good programmer. It's very appropriate for modeling things that are, in fact, objects - if I discuss a Card object with a fellow developer as well as a Deck object, the relationship between the two is not only plain but intuitive. It's certainly more than a way to keep spaghetti code organized.

     ### Key Takeaways
     * Wasting programmer time, not computer time, is the true inefficiency.
     * Each layer of interpretation (or abstraction) in a language costs a factor of ten in speed.

# Beating the Averages
     ### Summary
    If you want to be better than the average, that means being proportionally different from the average.

     ### Surprising Idea
    I never thought about it, but it's true that most startups follow a formula - and most startups fail. How can you expect to do the same thing as everyone else and get remarkably better results? It seems like there's even more to be gained by studying failures than there is studying successes.

     ### Unanswered
    A "Powerful" programming language, to me, either means "fast" or "turing-complete". The author is using a different definition that he never actually offers up.
  
     ### Objection
    I don't have any factual basis for disagreeing with his contention that Lisp is the most powerful of all programming languages, and I acknowledge that it would probably be worth my time to at least investigate it and see how it works. But the tone in which the opinion is presented reeks of the very "my pet language is the best language" bias he's trying to caution us against. In trying to avoid "hurt feelings" by not singling out a language, I actually feel like he undermined his own point and simultaneously ruffled my feathers very badly.

     ### Key Takeaways
     * When you write for the web, you can write in any language you want.
     * It's not immediately obvious when you're looking "up" at other languages; often it feels like you're looking sideways.
     * Languages are half technology and half religion.
     * The most harmless competitors are the ones that want Oracle experience in their programmers.
     * Ditto for Java and C++.

# Revenge of the Nerds
    ### Summary
    The author's favorite language is ten times as awesome as your favorite language, unless your favorite language is also Lisp.

     ### Surprising Idea
    What industry best practice actually gets you is not the best, but merely the average. I can see where this would be true in certain cases, for a short while. But at least in the open source community, I feel like someone that improves on a best practice resubmits it as the new best practice and it starts to get adopted. At best, I think this is a call to not be complacent with existing best practices; different is not always better.

     ### Unanswered
    I'm starting to think that what he means by "powerful" is "elegant" - he explicitly acknowledges that all turing-complete languages are technically as powerful as each other, but that Lisp is more "powerful" because you can do things in fewer discrete syntactic elements. But he seems to contradict that elsewhere - I do wish that he stated somewhere, plainly, how he defines "powerful" in terms of programming languages.

     ### Objection
    On the one hand, the author stresses the point that not all programming languages are equal, that you should select one where you can find the right talent and get the right job done and that sits in the appropriate place in the power matrix. On the other hand, it's apparently demonstrable fact that since 1958, the correct answer to that question has always been "Lisp". And if you make a programming language as powerful as Lisp, it's because you've made a new dialect of Lisp. Really? And he doesn't think he's got any pet-language bias?

     ### Key Takeaways
    * If there were any takeaways, they were drowned out by the constant fawning over Lisp.

# The Dream Language
     ### Summary
    There is such a thing as an ideal programming language.

     ### Surprising Idea
    I thought it was odd that the author would try to describe a universally ideal medium for all developers. It would be like trying to describe an ideal paint for all artists; there are probably some things that are generally true but I think that a lot of the remainder would be personal preference.

     ### Unanswered
    Why is twenty hackers enough to legitimize a language as real? It seems a low number to me.

     ### Objection 
    The "perfect language" has a whiff of Lisp about it. I wonder why that would be? </sarcasm>

     ### Key Takeaways
    * A programming language without a target (that is, something to hack) is useless.


# Design and Research
     ### Summary
    Design has to be good and research has to be new.
     
     ### Surprising Idea
    That a designer has to interpret their client's needs like a doctor needs to interpret their patients' symptoms. It's an interesting way of looking at it, but I agree with the sentiment.

     ### Unanswered
    If languages are a form for developing programs, and not for finished programs (just as wax is for sketching a sculpture and marble is for finishing it) - does that mean that when a program is finished, it should be translated into a final, more optimized language?

     ### Objection
    I don't find anything particularly contentious in this chapter - I agree with his sentiments on design and research both.

     ### Key Takeaways
    * If you're designing for idiots, you're not designing anything good - even for idiots.
