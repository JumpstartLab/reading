## Chapter 1
*PragProg is a style that involves thinking beyond, making informed decisions, and allowing change to happen organically. 
####Tips
*Don't Make Lame Excuses: When things fail, try everything, and then provide options to collaborators. 
*Don't Live with Broken Windows: Fix broken code and bad design when you see it. 

## Chapter 2
*Keep Sotware DRY and smart so that your systems can allow and support change. 
####Tips
*Create environments that support reuse which will in turn support collaboration. 
*There are No Final Decisions: Code will continue to change and adapt. Allow for change and embrace it. 

## Chapter 3
*Being aware of tools will make your job easier. Sometimes, the GUI will mask solutions to problems that would be clear in plain text. 
####Tips
*Keep Knowledge in Plain Text: Plain Text will never leave us and using it will help you to increase productivity.
*Use the Command Shell: Like plain text, the command shell increases productivity and presents problems clearly without the mask of a GUI to trip you up.


## Chapter 4
*Perfect software does not exist, allow your resources and implementations to be fluid. 
####Tips
*Design by Contract: Keep a record of work that you do and allow the contract to make sure that code does not do more or less than promised. 
*Finish What You Start: A process that allocates a resource should also deallocate it. When you need to, nest allocations.

##Chapter 5 
*Life doesn't stand still. Neither can code that we write. 
####Tips 
* good Fences Make Good Neighbors. Decouple! 
* good way to stay flexible: write less code. 

##Chapter 6
*We should avoid programming by convenience in favor of programming deliberately. 
####Tips 
*You can estimate order of basic algorithms using common sense. 
*Refactor Early, Refactor Often. fewer headaches and terrible code later.  

##Chapter 7
*Does "seeing further" require you to predict the future? NO. 
####Tips 
*Dig for Requirements: They are oftend shrouded by misconceptions and assumptions. 
*Find the Box: Identify constraints and question your own methods (does it have to be done this way?).

##Chapter 8
*As soon as you have more than one person on a project: establish ground rules and delegate accordingly.
####Tips 
*Organize Around Functionality: don't seperate designers from coders and testers from database engineers.
*Coding Ain't Done Til All the Tests Run: 'Nuff Said. 