# Chapter 1

This chapter was about being responsible for your code. It's important to
constantly maintain your code before it gets into the weeds.

Software Entropy: Broken windows are important. If you don't constantly groom
your code, why will anyone care about it?
Your Knowledge Portfolio: If you aren't constantly learning, you're doing it
wrong. Sticking to one language and not learning new things will cause you to
stagnate.

# Chapter 2

Build systems in such a way that supports change. Abstract away the details in
your subsystems so they can be interchangeable. Be agile.

Orthoganality: Changes in your system need to be isolated to that subsystem. If
they aren't your application will be brittle.
Tracer Bullets: End-to-end applications that act like psudeo-prototypes are
important when understanding how systems connect.

# Chapter 3

Developers are craftsmen. They need tools to make their jobs easier so they can
focus on producing quality products.

Shell Games: Using command-line tools makes my life so much easier. You're not
a developer if you don't use them ;)
Debugging: Debugging can be scary and daunting, but if you realize it's just a
problem that needs to be solved, you can jump right in and start breaking it
down.

# Chapter 4

Defensive programming is important when writing code. By having a set of rules
to follow (contracts) you can write code producing expected and repeatable
results.

Design by Contract: Pre/Post conditions and invariants are a great way to
specify what your methods do. It's invaluable when reading code that you 
didn't write.
When to use Exceptions: Exceptions are a good thing, except when you use them
in cases that aren't exceptional. Unexpected behaviors warrent exceptions.
Error conditions do not.

# Chapter 5

Introducing change into your system is inevitable. If you don't prepare for
change your code will be brittle and susceptible to bugs.

Decoupling and the Law of Demeter: Any method of an object should call only
methods belonging to: itself, passed parameters, objects it created, and any
objects held by itself.
Temporal Coupling: Code that is coupled to time can become brittle and
difficult to adapt to concurrent code. 

# Chapter 6

Understanding why a program works is 100 times more important than getting a
program to do something. You'll be in a hard place if you don't understand why 
something works, when something breaks or you want to change it's functionality.

Programming by Coincidence: When something works by chance or you write code 
haphazardly to get it functional, you're doing it wrong because you don't
understand anything that you wrote.
Evil Wizards: This is related to programming by coincidence in that wizards
write code that you may not understand so it is important to be cautious when
creating sub-systems generated by wizards.

# Chapter 7 

Figuring out what you should build is critical to creating applications that 
solve users problems.

Solving Impossible Puzzles: Finding the box to understand what problem to solve 
is important. If the wrong problem is solved, that is just as bad as not
solving the problem at all. 

Not Until You're Ready: Your developer intuition is an integral part of
development. This is the same idea behind "code smells." Something feels wrong so
you should heed your thoughts and think about why.

# Chapter 8

Creating teams of pragmatic programmers is possible using techniques for
individuals. There needs to be care given to constant feedback loops via:
continuous integration, testing, and documentation

Ubiquitous Automation: Everything that can be automated should. Developers must
offload tasks that can be automated to focus on solving tought problems.

Ruthless Testing: When a human finds a bug, that should be the last time a
human encounters that bug. Ruthless testing means to create a test for the bug
and automating detection of that behavior. Everything from unit to regression
testing must be addressed.
