## Chapter 1
"Pragmatic programming stems from a philosophy of pragmatic thinking."  Focus on good-enough software, communication, & keeping your knowledge portfolios current.

# Good-Enough Software
Code just enough to get the product out.  Let users tell you how good the software is & what needs to change.  Don't let get lost in the details.

# Your Knowledge Portfolio
Treat your software knowledge like a financial one.  Invest early & often.  Review periodically; & diversify w/ high-risk & low-risk for max yield.


## Chapter 2
Pragmatic process tips & tricks help you "write code that's better, faster, and stronger."  Minimize duplication & maximize adaptability.

# Orthogonality
Orthogonal software has modules with independence.  Changes in one requires minimal change in others.  Results are inc. productivity with less risk.

# Estimating
When estimating, break tasks into components & sum ind. estimates.  Use the right unit of time & when asked, "I'll get back to you" is auto-answer no. 1.


## Chapter 3
Proper tools can amplify your ability.  "Let need drive your acquisitions" of new ones.  When opting for power tools, know the basics first.

# Source Code Control
Source code control = project-wide "undo" key + tracking changes over time + dev accountability.  Experiments can be sandboxed & builds repeated.

# Debugging
Bugs are puzzles to be solved, not opps. for finger-pointing.  First find the intro point, gather all rel. data, trace the source, test the fix.


## Chapter 4
Understand no one's code is perfect.  Take measures to defend against mistakes, esp. your own.  When in doubt, play it safe.

# Design by Contract
Design by Contract to ensure program correctness.  Set clear expectations for modules, etc. of what's accepted & expected.

# Assertive Programming
"If It Can't Happen, Use Assertions to Ensure That It Won't." But "don't use assertions in place of real error handling."